\chapter{HTTP Communication}

In this short chapter, we present basics of HTTP communication. We do not aim to cover every topic deeply and throughoutly but rather to provide stable theoretical ground for assignment mirroring, which we write about in chapter \ref{sec:mirroring}.
Therefore we reduce our efforts into few  concept, which are referenced later in this work.

\section{HTTP headers and status codes}
HTTP message headers are used to precisely describe the resource being fetched or the behavior of the server or the client. \cite{mozzila} For each HTTP request, headers are served both on request and response side. Example of server response headers may be found in Listing \ref{lst:httpresponse}. These headers were received by a web browser after requesting an URL \texttt{http://www.st.fmph.uniba.sk/\textasciitilde trungel2/}.

\begin{lstlisting}[caption={Http response headers},label={lst:httpresponse}]
HTTP/1.1 200 OK
Date: Sat, 23 Apr 2016 09:44:20 GMT
Server: Apache/2.2.22 (Debian)
Last-Modified: Thu, 04 Dec 2014 22:14:43 GMT
ETag: "19c3fde-94-5096b498ca587"
Accept-Ranges: bytes
Vary: Accept-Encoding
Content-Encoding: gzip
Content-Length: 126
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html
\end{lstlisting}

First line of HTTP response headers shown in Listing \ref{lst:httpresponse} signals that request was processed correctly and the result is transmitted after these headers. The number \texttt{200} is called HTTP status code. There are five classes of status codes, each of them for signalizing something different. For our purposes, we only focus on some of them:

\begin{itemize}
\item 200 OK - Web server is signalizing that everything went OK and the response is sent after message headers.
\item 301 Moved Permanently, 302 Found, 303 See Other - This status codes signalizes, that our request needs to be redirected on a different URL
\item 4xx, 5xx - By this two classes of status codes the server signalizes an error. 4xx status code means an client side error, 5xx means server side error.
\end{itemize} 

We also need to explain some header directives, which we will be processing lager. These directives are:

\begin{itemize}
\item Content-Type: Indicates the MIME type of the served document. This helps the user agent (browser) to understand what to do with the received data. \cite{mozzila}
\item Location: Present on 3xx status codes. This directive points to the URL, client needs to be redirected.
\item Cookie, Set-Cookie: State variable in HTTP protocol. We are focusing on Cookies in Section \ref{sec:cookies}.
\end{itemize}


\section{Cookies}
\label{sec:cookies}
Cookie is a tool used to maintain state variables concerning the World Wide Web. A cookie can take the form of an HTTP header that consists of a string of information about the visit that is entered into the memory of the browser. This string may contain the domain, path, lifetime, and value of a variable, among other type of information \cite{reiche2000http}.

Cookie are usually set by a server to recognize the client since HTTP protocol is state less. There are many options cookies may be used to, however in our context we are going to use Cookies for user logging in. In such case, Cookie is generated by the server after it received correct username and password and this Cookie then must be sent by a client on each subsequent request.


\section{PHP/Curl}
While PHP is capable when it comes to simple file downloads, most real-life applications require additional functionality to handle advanced issues such as form submission, authentication, redirection and so on. These functions are difficult to facilitate with PHP's build-in functions alone. Fortunately, there is a library called PHP/CURL, which automatically takes care of advanced topics.  \cite{curl} 


\begin{lstlisting}[caption={Example of PHP/Curl usage},label={lst:phpcurl}]
// Init curl
$curl = curl_init("http://google.com/");
// Seet options

curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36');

// send the request
$resp = curl_exec($curl);
// clear up resources
curl_close($curl);
\end{lstlisting}

Listing \ref{lst:phpcurl} shows an example of curl. In this example we firstly initialized curl library, with an URL we want to perform a request. Then, additional options as request header directives may be selected. Finally, the request is performed and the result is saved in \texttt{\$ resp} variable.

\section{Apache 2 and Mod\_rewrite}
Apache 2 is an Open Source HTTP Server Project with goal to develop and maintain an HTTP server for modern operating systems such as Windows or Unix \cite{modrewrite}. This tool is widely used with PHP programming language and we need to focus on one of its modules, \texttt{mod\_rewrite}. For further references about Apache 2, see \cite{modrewrite}.

Mod\_ewrite provides a way to modify incoming URL requests, dynamically, based on regular expression rules. This allows you to map arbitrary URLs onto your internal URL structure in any way you like.

It supports an unlimited number of rules and an unlimited number of attached rule conditions for each rule to provide a really flexible and powerful URL manipulation mechanism. The URL manipulations can depend on various tests: server variables, environment variables, HTTP headers, time stamps, external database lookups, and various other external programs or handlers, can be used to achieve granular URL matching \cite{modrewrite}.

For this URL manipulation, \texttt{mod\_rewrite} uses rewrite rules. Example of these rules may be found in Listing \ref{lst:rewriterule}. This rule redirects request for \texttt{foo.html} into \texttt{bar.html}. 



\begin{lstlisting}[caption={Example rewrite rule},label={lst:rewriterule}]
RewriteEngine  on
RewriteRule    "^/foo\.html$"  "/bar.html" [PT]
\end{lstlisting}

In Conclusion, \texttt{mod\_rewite} has very powerful applications, which we are using later in this work.








